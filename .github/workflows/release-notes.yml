# yamllint disable rule:line-length
# yamllint disable rule:truthy
---
name: Release notes

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to summarize (must be merged)"
        required: true
        type: number
  repository_dispatch:
    types:
      - release-notes.requested

permissions:
  contents: write  # needed to push branch with CHANGELOG edits
  pull-requests: write  # needed to open a PR

jobs:
  summarize:
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'repository_dispatch' && github.event.action == 'release-notes.requested')
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GITHUB_MCP_PAT: ${{ secrets.CROSS_REPO_TOKEN }}
      GH_TOKEN: ${{ secrets.CROSS_REPO_TOKEN }}
      SOURCE_REPO: "laminlabs/laminhub"
      REPO: ${{ github.repository }}
      PR_NUMBER_DISPATCH: ${{ github.event.client_payload.pr_number }}
      PR_NUMBER_INPUT: ${{ inputs.pr_number }}

    steps:
      - name: Validate secrets & install deps
        run: |
          test -n "$OPENAI_API_KEY"  || { echo "Missing OPENAI_API_KEY"; exit 1; }
          test -n "$GITHUB_MCP_PAT" || { echo "Missing GITHUB_MCP_PAT"; exit 1; }

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout source repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.SOURCE_REPO }}
          path: source
          fetch-depth: 0
          token: ${{ secrets.CROSS_REPO_TOKEN }}

      - name: Gather release context
        id: basics
        env:
          EVENT_NAME: ${{ github.event_name }}
        run: |
          set -euo pipefail

          PR_NUMBER="${PR_NUMBER_DISPATCH:-}"
          if [ -z "$PR_NUMBER" ]; then
            PR_NUMBER="${PR_NUMBER_INPUT:-}"
          fi

          test -n "$PR_NUMBER" || { echo "PR number not provided"; exit 1; }

          PR_JSON=$(gh pr view "$PR_NUMBER" --repo "$SOURCE_REPO" \
            --json number,title,mergedAt,baseRefName,headRefName,mergeCommit,url)
          echo "$PR_JSON" | jq .

          BASE=$(echo "$PR_JSON" | jq -r '.baseRefName')
          HEAD=$(echo "$PR_JSON" | jq -r '.headRefName')
          if [ "$BASE" != "prod" ] || [ "$HEAD" != "main" ]; then
            echo "PR #$PR_NUMBER targets $HEAD -> $BASE; expected main -> prod."
            exit 1
          fi

          MERGED_AT=$(echo "$PR_JSON" | jq -r '.mergedAt // ""')
          test -n "$MERGED_AT" || { echo "Missing mergedAt timestamp"; exit 1; }

          MERGE_SHA=$(echo "$PR_JSON" | jq -r '.mergeCommit.oid // ""')
          test -n "$MERGE_SHA" || { echo "Missing merge commit SHA"; exit 1; }

          RELEASE_DATE=$(date -u -d "$MERGED_AT" +%F)

          TITLE=$(echo "$PR_JSON" | jq -r '.title // ""')

          {
            printf 'PR_NUMBER=%s\n' "$PR_NUMBER"
            printf 'MERGE_SHA=%s\n' "$MERGE_SHA"
            printf 'MERGED_AT=%s\n' "$MERGED_AT"
            printf 'DATE_STR=%s\n' "$RELEASE_DATE"
            printf 'TITLE=%s\n' "$TITLE"
          } >> "$GITHUB_ENV"

      - name: Resolve release tag (prefer PR title, fallback to tags)
        run: |
          set -euo pipefail

          git -C source fetch origin prod
          git -C source fetch --tags --force

          git -C source rev-parse "$MERGE_SHA" >/dev/null 2>&1 || {
            echo "Merge commit $MERGE_SHA not found locally.";
            exit 1;
          }

          # 1) Try extracting a semantic version from the PR title (e.g., "Release 0.40.0" or "v0.40.0")
          TITLE_VER=$(printf '%s\n' "${TITLE:-}" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -n 1 || true)
          if [ -n "${TITLE_VER:-}" ]; then
            RELEASE_TAG=${TITLE_VER#v}
          else
            # 2) Fallback: choose the earliest tag that contains the merge commit (first release that picked it up)
            RELEASE_TAG=$(git -C source tag --contains "$MERGE_SHA" | sort -V | head -n 1)
          fi
          test -n "$RELEASE_TAG" || { echo "No release tag found containing $MERGE_SHA"; exit 1; }

          echo "RELEASE_TAG=$RELEASE_TAG" >> $GITHUB_ENV

      - name: Build system prompt (Release Notes + embedded example + MCP guidance)
        run: |
          cat > system.txt <<'SYS'
          You are a release engineer producing release notes.

          Directives:
          - Summarize the specified merged PR using ONLY evidence from GitHub.
          - If uncertain, USE the GitHub MCP tools to fetch PR metadata, commits, changed files, targeted diffs, and—if needed—open files at the merge commit to inspect code context.
          - Keep tool calls minimal but sufficient to eliminate ambiguity.
          - Prioritize user-facing impact: surface what changes for users/admins, and collapse internal refactors unless they alter observable behavior.
          - When multiple minor tweaks roll up to one outcome, describe the outcome once instead of listing each tweak.

          Output policy:
          - Output MUST be GitHub-flavored Markdown in this structure; omit any empty sections:

          ## {DATE_YYYY_MM_DD} ({RELEASE_TAG})

          New Features
          - <Category>
            - <bullets>

          Changes
          - <Category>
            - <bullets>

          Bug fixes
          - <Category>
            - <bullets>

          Bullet rules:
          - The heading must read `## {DATE_YYYY_MM_DD} ({RELEASE_TAG})` with the provided tag immediately after the date.
          - Highlight outcomes users notice; skip file/function names, internal acronyms, and helper plumbing (e.g., RLS/JWT SQL, submodule bumps, policy code).
          - One sentence per bullet on a single line.
          - No empty lines within a section. Only one blank line after the heading and exactly one blank line between top-level sections (New Features, Changes, Bug fixes).
          - Prefer 1 bullet per category; add a 2nd only if it is clearly distinct and user-visible.
          - Merge related tweaks into one concise bullet; mention implementation mechanics only if essential for clarity.
          - Short category labels (e.g., “Workflows & Launch”, “Storage & Artifacts”).
          - Use plain, user-facing language; no marketing language.

          Few-shot exemplar (match style & depth):

          ## 2025-10-22

          New Features

          - Workflows & Launch
            - Launch forms can reveal hidden parameters when needed, a simplified launch view is available, and Nextflow schema JSON is respected end-to-end. Run metadata originating from Sheets is captured for better traceability.
          - Transforms & Pipelines
            - Pipeline repository information is automatically derived from transform source code to improve provenance and linking.
            - Branch parameter is supported when resolving repository details for transforms.
          - Analytics & Group-By
            - Group-by charts support sorting for clearer comparisons.
          - Access & Security
            - Record-level locking via RLS for individual records and Block models.
          - Storage
            - Default bucket lookup by instance ID is available; deletion of storage resources is supported; and Lambda now returns IDs for newly created artifacts and storages.

          Changes

          - Runs & Reports
            - Run logs render ANSI colors for readability; version tags no longer auto-prepend “v”; run counters increment per transform (not per version) for clearer numbering.
          - Navigation & UI
            - Registries nav reordered; sub-navigation expanded for Artifacts and Features; Sheets show feature descriptions on hover; hide internal “n” in schema tables; assorted copy/title refinements.
            - Team page copy/typos corrected; vocabulary renamed “linked features” → “external features”.
          - Workflows & Pipelines
            - Only main-branch schemas appear in pipeline configuration; configuration files are hidden by default; `input`/`outdir` receive no special treatment so the Nextflow schema is the single source of truth.
            - Parameters show a loading state during launch configuration.
          - Performance & Stability
            - Instance caching optimized with a robust fallback.
          - Platform & Observability
            - LaminDB upgraded to 1.12 with follow-up bumps; database resource metadata expanded (host/port/proxy) and schema SQL functions marked STABLE.
          - Permissions & Governance
            - Expanded permissions for org admins/managers; more consistent JWT/DB user mapping for org members.

          Bug fixes

          - Sheets
            - Normalize floats on submission; restore Save after manual import; hide non-schema self-referential features; correct feature-card dtype display and field-search scope; fix sheet creation button in schema.
          - Pipelines & Transforms
            - Resolve transform load errors; pipeline configuration shows only main-branch schemas; use the correct `name_field`; full-screen run report no longer flashes.
          - Storage & Artifacts
            - Include file extension when uploading artifacts; improve reliability of instance DB transfer.
          - Navigation & Tables
            - Fix nav flicker and active-page highlight; correct org-page navbar links; table selector uses fuzzy search; access table command bars use the correct accessor keys; remove description column from ULabel tables; fix artifacts page reactivity issues.
          - Database & Query
            - Fix collaborator-access RLS and JWT DB-user retrieval for org members.
          SYS

      - name: Build user message
        run: |
          cat > user.txt <<EOF
          Repository: ${SOURCE_REPO}
          PR number: ${PR_NUMBER}
          Release date (for heading): ${DATE_STR}
          Release tag: ${RELEASE_TAG}
          Merge commit: ${MERGE_SHA}

          Task:
          - Produce the release notes for the merged PR above.
          - If any ambiguity or missing detail prevents confident attribution, use the GitHub MCP tools to fetch commits, files, diffs, and (if needed) file contents at the merge commit before writing the output.
          EOF

      - name: Call OpenAI Responses API with GitHub MCP tools
        id: call_openai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_MCP_PAT: ${{ secrets.CROSS_REPO_TOKEN }}
        run: |
          jq -n \
            --arg model "gpt-5" \
            --arg sys "$(cat system.txt)" \
            --arg usr "$(cat user.txt)" \
            '{
              model: $model,
              input: [
                { "role": "system", "content": [ { "type":"input_text", "text": $sys } ] },
                { "role": "user",   "content": [ { "type":"input_text", "text": $usr } ] }
              ],
              tools: [
                {
                  "type": "mcp",
                  "server_label": "github",
                  "server_url": "https://api.githubcopilot.com/mcp/",
                  "headers": { "Authorization": ("Bearer " + env.GITHUB_MCP_PAT) },
                  "require_approval": "never"
                }
              ],
              max_output_tokens: 8000
            }' > payload.json

          http=$(curl -sS -w "%{http_code}" -o response.json \
            https://api.openai.com/v1/responses \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            --data-binary @payload.json)
          echo "OpenAI HTTP: $http"
          [ "$http" -ge 200 ] && [ "$http" -lt 300 ] || { echo "OpenAI error:"; cat response.json; exit 1; }

          STATUS=$(jq -r '.status // "unknown"' response.json)
          if [ "$STATUS" != "completed" ]; then
            REASON=$(jq -r '.incomplete_details.reason // "unspecified"' response.json)
            echo "Model status=$STATUS (reason: $REASON)"
            cat response.json
            exit 1
          fi

          SUMMARY=$(
            jq -r '
              .output_text //
              (.output[]? | select(.type=="message") | .content[]? | select(.type=="output_text" or .type=="text") | .text) //
              .choices[0].message.content // ""' response.json
          )
          [ -n "$SUMMARY" ] && [ "$SUMMARY" != "null" ] || { echo "Empty model output"; cat response.json; exit 1; }
          printf "%s\n" "$SUMMARY" > summary.md

      - name: Create branch, prepend to docs/changelog/soon/laminhub.md, and commit
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          RUN_ID_SHORT=${GITHUB_RUN_ID:0:8}
          [ -n "$RUN_ID_SHORT" ] || RUN_ID_SHORT=$GITHUB_RUN_ID
          BRANCH="chore/changelog/pr-${PR_NUMBER}-${RUN_ID_SHORT}"
          echo "BRANCH=$BRANCH" >> "$GITHUB_ENV"
          git checkout -b "$BRANCH" "origin/main"

          TARGET_FILE="docs/changelog/soon/laminhub.md"
          TMP_FILE="${TARGET_FILE}.tmp"

          if [ -f "$TARGET_FILE" ]; then
            # Prepend the new summary to the top, with a blank line separator
            { cat summary.md; echo ""; cat "$TARGET_FILE"; } > "$TMP_FILE"
            mv "$TMP_FILE" "$TARGET_FILE"
          else
            mkdir -p "$(dirname "$TARGET_FILE")"
            cp summary.md "$TARGET_FILE"
          fi

          git add "$TARGET_FILE"
          git commit -m "chore(changelog): prepend release notes for PR #${PR_NUMBER} (${DATE_STR} – ${RELEASE_TAG})"

      - name: Push branch
        run: |
          git push -u origin "$BRANCH"

      - name: Open PR with CHANGELOG update
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_TOKEN }}
        run: |
          gh pr create \
            --repo "$REPO" \
            --base main \
            --head "$BRANCH" \
            --title "Changelog: ${RELEASE_TAG} – PR #${PR_NUMBER} (${DATE_STR})" \
            --body  "Prepends release notes generated from merged PR #${PR_NUMBER} (${RELEASE_TAG}) to docs/changelog/soon/laminhub.md."
